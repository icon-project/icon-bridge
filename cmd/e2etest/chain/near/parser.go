package near

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/big"
	"strings"

	// "strings"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/icon-project/icon-bridge/cmd/e2etest/chain"
	"github.com/icon-project/icon-bridge/cmd/iconbridge/chain/near/types"
	"github.com/pkg/errors"
)

const (
	ADD_TO_BLACKLIST      = 0
	REMOVE_FROM_BLACKLIST = 1
	BLACKLIST_MESSAGE     = 3
	CHANGE_TOKEN_LIMIT    = 4
	FEE_GATHERING         = "FeeGathering"
)

type AssetDetails struct {
	Name  string
	Value types.BigInt
	Fee   types.BigInt
}

type Event struct {
	Name            chain.EventLogType `json:"event"`
	Code            types.BigInt       `json:"code"`
	SenderAddress   types.AccountId    `json:"sender_address,omitempty"`
	SerialNumber    types.BigInt       `json:"serial_number"`
	ReceiverAddress chain.BTPAddress   `json:"receiver_address,omitempty"`
	Assets          []AssetDetails     `json:"assets,omitempty"`
	TokenName       string             `json:"token_name,omitempty"`
	Message         string             `json:"message,omitempty"`
	TokenAccount    types.AccountId    `json:"token_account,omitempty"`
}

type parser struct {
	addressToContractName map[string]chain.ContractName
}

func NewParser(nameToAddr map[chain.ContractName]string) (*parser, error) {
	addrToName := map[string]chain.ContractName{}
	for name, addr := range nameToAddr {
		addrToName[addr] = name
	}
	return &parser{addressToContractName: addrToName}, nil
}

func (p *parser) Parse(log string) (resLog interface{}, eventType chain.EventLogType, err error) {
	var event Event
	err = json.Unmarshal([]byte(log), &event)
	if err != nil {
		return nil, "", err
	}
	eventType = event.Name

	if eventType == chain.TransferStart {
		resLog, err = parseTransferStartTxn(log)
	} else if eventType == chain.TransferReceived {
		resLog, err = parseTransferReceivedTxn(log)
	} else if eventType == chain.TransferEnd {
		resLog, err = parseTransferEndTxn(log)
	} else {
		err = fmt.Errorf("no matching signature for event log for %v found", eventType)
	}
	return
}

func (p *parser) ParseTxnLog(log string) (resLog interface{}, eventType chain.EventLogType, err error) {
	var event Event
	err = json.Unmarshal([]byte(log), &event)
	if err != nil {
		return nil, "", err
	}
	eventType = event.Name
	if eventType == chain.TransferStart {
		resLog, err = parseTransferStartTxn(log)
	} else if eventType == chain.TransferReceived {
		resLog, err = parseTransferReceivedTxn(log)
	} else if eventType == chain.TransferEnd {
		resLog, err = parseTransferEndTxn(log)
	} else {
		err = fmt.Errorf("no matching signature for event log of type %v generated by contract address %v", eventType, log)
	}
	return
}

func (p *parser) ParseMessage(msg []byte) (res interface{}, eventType chain.EventLogType, err error) {

	bmcMsg := BMCMessage{
		Src:     "",
		Dst:     "",
		Svc:     "",
		Sn:      []byte{},
		Message: []byte{},
	}
	msgSn := (&big.Int{}).SetBytes(bmcMsg.Sn)

	svcMessage := ServiceMessage{}
	if err = rlpDecodeHex(hex.EncodeToString(bmcMsg.Message), &svcMessage); err != nil {
		err = errors.Wrapf(err, "rlpDecodeHex %v", err)
		return
	}
	svcTypeStr := string(svcMessage.ServiceType)
	svcTypeNum := (&big.Int{}).SetBytes(svcMessage.ServiceType).Int64()

	if svcTypeNum == BLACKLIST_MESSAGE {
		svcMessagePayload := ServiceBlacklistMessagePayload{}
		if err = rlpDecodeHex(hex.EncodeToString(svcMessage.Payload), &svcMessagePayload); err != nil {
			err = errors.Wrapf(err, "rlpDecodeHex %v", err)
			return
		}
		requestType := (&big.Int{}).SetBytes(svcMessagePayload.RequestType).Int64()
		if requestType == ADD_TO_BLACKLIST {
			return &chain.AddToBlacklistRequestEvent{
				Sn:    msgSn,
				Net:   svcMessagePayload.Net,
				Addrs: svcMessagePayload.Addresses,
			}, chain.AddToBlacklistRequest, nil
		} else if requestType == REMOVE_FROM_BLACKLIST {
			return &chain.RemoveFromBlacklistRequestEvent{
				Sn:    msgSn,
				Net:   svcMessagePayload.Net,
				Addrs: svcMessagePayload.Addresses,
			}, chain.RemoveFromBlacklistRequest, nil
		}
		err = fmt.Errorf("unexpected request type %v for blacklist Message ", requestType)
		return
	} else if svcTypeNum == CHANGE_TOKEN_LIMIT {
		svcMessagePayload := ServiceTokenlimitMessagePayload{}
		if err = rlpDecodeHex(hex.EncodeToString(svcMessage.Payload), &svcMessagePayload); err != nil {
			err = errors.Wrapf(err, "rlpDecodeHex %v", err)
			return
		}
		tokenLimits := make([]*big.Int, len(svcMessagePayload.TokenLimits))
		for i, v := range svcMessagePayload.TokenLimits {
			tokenLimits[i] = (&big.Int{}).SetBytes(v)
		}
		return &chain.TokenLimitRequestEvent{
			Sn:          msgSn,
			TokenLimits: tokenLimits,
			CoinNames:   svcMessagePayload.CoinNames,
		}, chain.TokenLimitRequest, nil
	} else if svcTypeStr == FEE_GATHERING {
		svcMessagePayload := ServiceFeeGatheringRequestPayload{}
		if err = rlpDecodeHex(hex.EncodeToString(svcMessage.Payload), &svcMessagePayload); err != nil {
			err = errors.Wrapf(err, "rlpDecodeHex %v", err)
			return
		}
		return &chain.FeeGatheringRequestEvent{
			FeeAggregator: svcMessagePayload.FeeAggregator,
			Services:      svcMessagePayload.Services,
		}, chain.FeeGatheringRequest, nil
	}
	err = fmt.Errorf("unexpected service type %v  ", svcTypeNum)
	return
}

func parseTransferEndTxn(log string) (res *chain.TransferEndEvent, err error) {
	var event Event
	err = json.Unmarshal([]byte(log), &event)
	if err != nil {
		return nil, err
	}

	te := &chain.TransferEndEvent{
		From:     string(event.SenderAddress),
		Sn:       (*big.Int)(&event.SerialNumber),
		Code:     (*big.Int)(&event.Code),
		Response: event.Message,
	}
	return te, nil
}

func parseTransferReceivedTxn(log string) (res *chain.TransferReceivedEvent, err error) {
	var event Event
	err = json.Unmarshal([]byte(log), &event)
	if err != nil {
		return nil, err
	}
	tr := &chain.TransferReceivedEvent{
		From:   string(event.SenderAddress),
		To:     string(event.ReceiverAddress),
		Sn:     (*big.Int)(&event.SerialNumber),
		Assets: []chain.AssetTransferDetails{},
	}
	resAsset := event.Assets
	for _, asset := range resAsset {
		v := big.Int(asset.Value)

		tr.Assets = append(tr.Assets, chain.AssetTransferDetails{
			Name:  asset.Name,
			Value: &v,
		})
	}
	return tr, nil

}

func parseTransferStartTxn(log string) (res *chain.TransferStartEvent, err error) {
	var event Event
	err = json.Unmarshal([]byte(log), &event)
	if err != nil {
		return nil, err
	}

	ts := &chain.TransferStartEvent{
		From:   string(event.SenderAddress),
		To:     string(event.ReceiverAddress),
		Sn:     (*big.Int)(&event.SerialNumber),
		Assets: []chain.AssetTransferDetails{},
	}
	resAsset := event.Assets
	for _, asset := range resAsset {
		v := big.Int(asset.Value)
		f := big.Int(asset.Fee)
		ts.Assets = append(ts.Assets, chain.AssetTransferDetails{
			Name:  asset.Name,
			Value: &v,
			Fee:   &f,
		})
	}

	return ts, nil

}

func rlpDecodeHex(str string, out interface{}) error {
	if strings.HasPrefix(str, "0x") {
		str = str[2:]
	}
	input, err := hex.DecodeString(str)
	if err != nil {
		return errors.Wrap(err, "hex.DecodeString ")
	}
	err = rlp.Decode(bytes.NewReader(input), out)
	if err != nil {
		return errors.Wrap(err, "rlp.Decode ")
	}
	return nil
}

type BMCMessage struct {
	Src     string //  an address of BMC (i.e. btp://1234.PARA/0x1234)
	Dst     string //  an address of destination BMC
	Svc     string //  service name of BSH
	Sn      []byte //  sequence number of BMC
	Message []byte //  serialized Service Message from BSH
}

type ServiceMessage struct {
	ServiceType []byte
	Payload     []byte
}

type ServiceBlacklistMessagePayload struct {
	RequestType []byte
	Addresses   []string
	Net         string
}

type ServiceTokenlimitMessagePayload struct {
	CoinNames   []string
	TokenLimits [][]byte
	Net         string
}

type ServiceFeeGatheringRequestPayload struct {
	FeeAggregator string
	Services      []string
}
