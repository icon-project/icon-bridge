package icon

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"math/big"
	"strings"

	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/icon-project/icon-bridge/cmd/e2etest/chain"
	"github.com/icon-project/icon-bridge/cmd/iconbridge/chain/icon"
	"github.com/icon-project/icon-bridge/common"
)

const (
	ADD_TO_BLACKLIST      = 0
	REMOVE_FROM_BLACKLIST = 1
	BLACKLIST_MESSAGE     = 3
	CHANGE_TOKEN_LIMIT    = 4
)

type parser struct {
	addressToContractName map[string]chain.ContractName
}

func NewParser(nameToAddr map[chain.ContractName]string) (*parser, error) {
	addrToName := map[string]chain.ContractName{}
	for name, addr := range nameToAddr {
		addrToName[addr] = name
	}
	return &parser{addressToContractName: addrToName}, nil
}

func (p *parser) ParseTxn(log *TxnEventLog) (resLog interface{}, eventType chain.EventLogType, err error) {
	eventName := strings.Split(string(log.Indexed[0]), "(")
	eventType = chain.EventLogType(strings.TrimSpace(eventName[0]))
	if eventType == chain.TransferStart {
		resLog, err = parseTransferStartTxn(log)
	} else if eventType == chain.TransferReceived {
		resLog, err = parseTransferReceivedTxn(log)
	} else if eventType == chain.TransferEnd {
		resLog, err = parseTransferEndTxn(log)
	} else if eventType == chain.Message {
		resLog, eventType, err = parseMessageTxn(log)
	} else {
		err = fmt.Errorf("No matching signature for event log of type %v generated by contract address %v", eventType, log.Addr)
	}
	return
}

func (p *parser) Parse(log *icon.EventLog) (resLog interface{}, eventType chain.EventLogType, err error) {
	eventName := strings.Split(string(log.Indexed[0]), "(")
	eventType = chain.EventLogType(strings.TrimSpace(eventName[0]))
	if eventType == chain.TransferStart {
		resLog, err = parseTransferStart(log)
	} else if eventType == chain.TransferReceived {
		resLog, err = parseTransferReceived(log)
	} else if eventType == chain.TransferEnd {
		resLog, err = parseTransferEnd(log)
	} else if eventType == chain.Message {
		resLog, eventType, err = parseMessage(log)
	} else {
		err = fmt.Errorf("No matching signature for event log of type %v generated by contract address %v", eventType, log.Addr)
	}
	return
}

func rlpDecodeHex(str string, out interface{}) error {
	if strings.HasPrefix(str, "0x") {
		str = str[2:]
	}
	input, err := hex.DecodeString(str)
	if err != nil {
		return errors.Wrap(err, "hex.DecodeString ")
	}
	err = rlp.Decode(bytes.NewReader(input), out)
	if err != nil {
		return errors.Wrap(err, "rlp.Decode ")
	}
	return nil
}

func parseMessageTxn(log *TxnEventLog) (res interface{}, evtType chain.EventLogType, err error) {
	if len(log.Data) != 1 {
		err = fmt.Errorf("Unexpected length of log.Data. Got %d. Expected 1", len(log.Data))
		return
	}
	if len(log.Indexed) != 3 {
		err = fmt.Errorf("Unexpected length of log.Indexed. Got %d. Expected 3", len(log.Data))
		return
	}
	bmcMsg := BMCMessage{}
	if err = rlpDecodeHex(log.Data[0], &bmcMsg); err != nil {
		err = errors.Wrapf(err, "rlpDecodeHex %v", err)
		return
	}
	msgSn := (&big.Int{}).SetBytes(bmcMsg.Sn)

	svcMessage := ServiceMessage{}
	if err = rlpDecodeHex(hex.EncodeToString(bmcMsg.Message), &svcMessage); err != nil {
		err = errors.Wrapf(err, "rlpDecodeHex %v", err)
		return
	}
	svcTypeNum := (&big.Int{}).SetBytes(svcMessage.ServiceType).Int64()

	if svcTypeNum == BLACKLIST_MESSAGE {
		svcMessagePayload := ServiceBlacklistMessagePayload{}
		if err = rlpDecodeHex(hex.EncodeToString(svcMessage.Payload), &svcMessagePayload); err != nil {
			err = errors.Wrapf(err, "rlpDecodeHex %v", err)
			return
		}
		requestType := (&big.Int{}).SetBytes(svcMessagePayload.RequestType).Int64()
		if requestType == ADD_TO_BLACKLIST {
			return &chain.AddToBlacklistRequestEvent{
				Sn:    msgSn,
				Net:   svcMessagePayload.Net,
				Addrs: svcMessagePayload.Addresses,
			}, chain.AddToBlacklistRequest, nil
		} else if requestType == REMOVE_FROM_BLACKLIST {
			return &chain.RemoveFromBlacklistRequestEvent{
				Sn:    msgSn,
				Net:   svcMessagePayload.Net,
				Addrs: svcMessagePayload.Addresses,
			}, chain.RemoveFromBlacklistRequest, nil
		}
		err = fmt.Errorf("Unexpected request type %v for blacklist Message ", requestType)
		return
	} else if svcTypeNum == CHANGE_TOKEN_LIMIT {
		svcMessagePayload := ServiceTokenlimitMessagePayload{}
		if err = rlpDecodeHex(hex.EncodeToString(svcMessage.Payload), &svcMessagePayload); err != nil {
			err = errors.Wrapf(err, "rlpDecodeHex %v", err)
			return
		}
		tokenLimits := make([]*big.Int, len(svcMessagePayload.TokenLimits))
		for i, v := range svcMessagePayload.TokenLimits {
			tokenLimits[i] = (&big.Int{}).SetBytes(v)
		}
		return &chain.TokenLimitRequestEvent{
			Sn:          msgSn,
			TokenLimits: tokenLimits,
			CoinNames:   svcMessagePayload.CoinNames,
		}, chain.TokenLimitRequest, nil
	}
	err = fmt.Errorf("Unexpected service type %v  ", svcTypeNum)
	return
}

func parseMessage(log *icon.EventLog) (res interface{}, evtType chain.EventLogType, err error) {
	if len(log.Data) != 1 {
		err = fmt.Errorf("Unexpected length of log.Data. Got %d. Expected 1", len(log.Data))
		return
	}
	if len(log.Indexed) != 3 {
		err = fmt.Errorf("Unexpected length of log.Indexed. Got %d. Expected 3", len(log.Data))
		return
	}
	addr := common.HexBytes(log.Addr).String()
	indexed := make([]string, len(log.Indexed))
	for i, v := range log.Indexed {
		indexed[i] = common.HexBytes(v).String()
	}
	data := make([]string, len(log.Data))
	for i, v := range log.Data {
		data[i] = common.HexBytes(v).String()
	}
	return parseMessageTxn(
		&TxnEventLog{
			Addr:    icon.Address(addr),
			Indexed: indexed,
			Data:    data,
		},
	)
}

func parseTransferStart(log *icon.EventLog) (*chain.TransferStartEvent, error) {
	if len(log.Data) != 3 {
		return nil, fmt.Errorf("Unexpected length of log.Data. Got %d. Expected 3", len(log.Data))
	}
	//logAddr := common.NewAddress(log.Addr).String()
	var sn common.HexInt
	sn.SetBytes(log.Data[1])

	res := []AssetTxDetails{}
	err := rlp.Decode(bytes.NewReader(log.Data[2]), &res)
	if err != nil {
		fmt.Println(err)
		return nil, errors.Wrapf(err, "rlp.Decode %v", err)
	}

	ts := &chain.TransferStartEvent{
		From:   common.NewAddress(log.Indexed[1]).String(),
		To:     string(log.Data[0]),
		Sn:     big.NewInt(sn.Int64()),
		Assets: []chain.AssetTransferDetails{},
	}
	for _, r := range res {
		f := new(big.Int)
		f.SetString(hexutil.Encode(r.Fee)[2:], 16)
		v := new(big.Int)
		v.SetString(hexutil.Encode(r.Value)[2:], 16)

		ts.Assets = append(ts.Assets, chain.AssetTransferDetails{
			Name:  r.Name,
			Value: v,
			Fee:   f,
		})
	}
	return ts, nil
}

func parseTransferReceived(log *icon.EventLog) (*chain.TransferReceivedEvent, error) {
	if len(log.Data) != 2 || len(log.Indexed) != 3 {
		return nil, fmt.Errorf("Unexpected length. Got %v and %v. Expected 2 and 3", len(log.Data), len(log.Indexed))
	}

	res := []AssetTx{}
	err := rlpDecodeHex(common.HexBytes(log.Data[1]).String(), &res)
	if err != nil {
		return nil, errors.Wrap(err, "rlp.DecodeHex ")
	}
	var sn common.HexInt
	sn.SetBytes(log.Data[0])

	ts := &chain.TransferReceivedEvent{
		From:   string(log.Indexed[1]),
		To:     common.NewAddress(log.Indexed[2]).String(),
		Sn:     big.NewInt(sn.Int64()),
		Assets: []chain.AssetTransferDetails{},
	}
	for _, r := range res {
		v := new(big.Int)
		v.SetString(hexutil.Encode(r.Value)[2:], 16)

		ts.Assets = append(ts.Assets, chain.AssetTransferDetails{
			Name:  r.Name,
			Value: v,
		})
	}
	return ts, nil
}

func parseTransferEnd(log *icon.EventLog) (*chain.TransferEndEvent, error) {
	var sn common.HexInt
	sn.SetBytes(log.Data[0])

	var cd common.HexInt
	cd.SetBytes(log.Data[1])
	response := ""
	if len(log.Data[2]) > 0 {
		response = string(log.Data[2])
	}
	te := &chain.TransferEndEvent{
		From:     common.NewAddress(log.Indexed[1]).String(),
		Sn:       big.NewInt(sn.Int64()),
		Code:     big.NewInt(cd.Int64()),
		Response: response,
	}
	return te, nil
}

func parseTransferStartTxn(log *TxnEventLog) (*chain.TransferStartEvent, error) {
	if len(log.Data) != 3 {
		return nil, fmt.Errorf("Unexpected length of log.Data. Got %d. Expected 3", len(log.Data))
	}
	data := log.Data
	res := []AssetTxDetails{}
	err := rlpDecodeHex(data[len(data)-1], &res)
	if err != nil {
		return nil, errors.Wrapf(err, "rlpDecodeHex %v", err)
	}
	sn := new(big.Int)
	if strings.HasPrefix(data[1], "0x") {
		data[1] = data[1][2:]
	}
	sn.SetString(data[1], 16)
	ts := &chain.TransferStartEvent{
		From:   log.Indexed[1],
		To:     data[0],
		Sn:     sn,
		Assets: []chain.AssetTransferDetails{},
	}

	for _, r := range res {
		f := new(big.Int)
		f.SetString(hexutil.Encode(r.Fee)[2:], 16)
		v := new(big.Int)
		v.SetString(hexutil.Encode(r.Value)[2:], 16)

		ts.Assets = append(ts.Assets, chain.AssetTransferDetails{
			Name:  r.Name,
			Value: v,
			Fee:   f,
		})
	}
	return ts, nil
}

func parseTransferReceivedTxn(log *TxnEventLog) (*chain.TransferReceivedEvent, error) {
	if len(log.Data) != 2 || len(log.Indexed) != 3 {
		return nil, fmt.Errorf("Unexpected length. Got %v and %v. Expected 2 and 3", len(log.Data), len(log.Indexed))
	}
	data := log.Data
	res := []AssetTx{}
	err := rlpDecodeHex(data[len(data)-1], &res)
	if err != nil {
		return nil, errors.Wrap(err, "rlp.DecodeHex ")
	}
	sn := new(big.Int)
	if strings.HasPrefix(data[0], "0x") {
		data[0] = data[0][2:]
	}
	sn.SetString(data[0], 16)

	ts := &chain.TransferReceivedEvent{
		From:   log.Indexed[1],
		To:     log.Indexed[2],
		Sn:     sn,
		Assets: []chain.AssetTransferDetails{},
	}
	for _, r := range res {
		v := new(big.Int)
		v.SetString(hexutil.Encode(r.Value)[2:], 16)

		ts.Assets = append(ts.Assets, chain.AssetTransferDetails{
			Name:  r.Name,
			Value: v,
		})
	}
	return ts, nil
}

func parseTransferEndTxn(log *TxnEventLog) (*chain.TransferEndEvent, error) {
	data := log.Data
	sn := new(big.Int)
	if strings.HasPrefix(data[0], "0x") {
		data[0] = data[0][2:]
	}
	sn.SetString(data[0], 16)

	cd := new(big.Int)
	if strings.HasPrefix(data[1], "0x") {
		data[1] = data[1][2:]
	}

	cd.SetString(data[1], 16)
	te := &chain.TransferEndEvent{
		From:     log.Indexed[1],
		Sn:       sn,
		Code:     cd,
		Response: data[2],
	}
	return te, nil
}

type AssetTxDetails struct {
	Name  string
	Value []byte
	Fee   []byte
}

type AssetTx struct {
	Name  string
	Value []byte
}

type BMCMessage struct {
	Src     string //  an address of BMC (i.e. btp://1234.PARA/0x1234)
	Dst     string //  an address of destination BMC
	Svc     string //  service name of BSH
	Sn      []byte //  sequence number of BMC
	Message []byte //  serialized Service Message from BSH
}

type ServiceMessage struct {
	ServiceType []byte
	Payload     []byte
}

type ServiceBlacklistMessagePayload struct {
	RequestType []byte
	Addresses   []string
	Net         string
}

type ServiceTokenlimitMessagePayload struct {
	CoinNames   []string
	TokenLimits [][]byte
	Net         string
}
