// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"
	big "math/big"

	common "github.com/icon-project/goloop/common"

	mock "github.com/stretchr/testify/mock"

	types "github.com/icon-project/icon-bridge/cmd/iconbridge/chain/icon/types"

	websocket "github.com/gorilla/websocket"
)

// ClientMock is an autogenerated mock type for the IClient type
type ClientMock struct {
	mock.Mock
}

// Call provides a mock function with given fields: p, r
func (_m *ClientMock) Call(p *types.CallParam, r interface{}) error {
	ret := _m.Called(p, r)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.CallParam, interface{}) error); ok {
		r0 = rf(p, r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloseAllMonitor provides a mock function with given fields:
func (_m *ClientMock) CloseAllMonitor() {
	_m.Called()
}

// CloseMonitor provides a mock function with given fields: conn
func (_m *ClientMock) CloseMonitor(conn *websocket.Conn) {
	_m.Called(conn)
}

// GetBalance provides a mock function with given fields: param
func (_m *ClientMock) GetBalance(param *types.AddressParam) (*big.Int, error) {
	ret := _m.Called(param)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*types.AddressParam) *big.Int); ok {
		r0 = rf(param)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.AddressParam) error); ok {
		r1 = rf(param)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByHeight provides a mock function with given fields: p
func (_m *ClientMock) GetBlockByHeight(p *types.BlockHeightParam) (*types.Block, error) {
	ret := _m.Called(p)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func(*types.BlockHeightParam) *types.Block); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.BlockHeightParam) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeaderByHeight provides a mock function with given fields: height
func (_m *ClientMock) GetBlockHeaderByHeight(height int64) (*types.BlockHeader, error) {
	ret := _m.Called(height)

	var r0 *types.BlockHeader
	if rf, ok := ret.Get(0).(func(int64) *types.BlockHeader); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHeaderBytesByHeight provides a mock function with given fields: p
func (_m *ClientMock) GetBlockHeaderBytesByHeight(p *types.BlockHeightParam) ([]byte, error) {
	ret := _m.Called(p)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*types.BlockHeightParam) []byte); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.BlockHeightParam) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitVoteListByHeight provides a mock function with given fields: height
func (_m *ClientMock) GetCommitVoteListByHeight(height int64) (*types.CommitVoteList, error) {
	ret := _m.Called(height)

	var r0 *types.CommitVoteList
	if rf, ok := ret.Get(0).(func(int64) *types.CommitVoteList); ok {
		r0 = rf(height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CommitVoteList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64) error); ok {
		r1 = rf(height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataByHash provides a mock function with given fields: p
func (_m *ClientMock) GetDataByHash(p *types.DataHashParam) ([]byte, error) {
	ret := _m.Called(p)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*types.DataHashParam) []byte); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.DataHashParam) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastBlock provides a mock function with given fields:
func (_m *ClientMock) GetLastBlock() (*types.Block, error) {
	ret := _m.Called()

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func() *types.Block); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProofForEvents provides a mock function with given fields: p
func (_m *ClientMock) GetProofForEvents(p *types.ProofEventsParam) ([][][]byte, error) {
	ret := _m.Called(p)

	var r0 [][][]byte
	if rf, ok := ret.Get(0).(func(*types.ProofEventsParam) [][][]byte); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.ProofEventsParam) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProofForResult provides a mock function with given fields: p
func (_m *ClientMock) GetProofForResult(p *types.ProofResultParam) ([][]byte, error) {
	ret := _m.Called(p)

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func(*types.ProofResultParam) [][]byte); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.ProofResultParam) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetValidatorsByHash provides a mock function with given fields: hash
func (_m *ClientMock) GetValidatorsByHash(hash common.HexHash) ([]common.Address, error) {
	ret := _m.Called(hash)

	var r0 []common.Address
	if rf, ok := ret.Get(0).(func(common.HexHash) []common.Address); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.HexHash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVotesByHeight provides a mock function with given fields: p
func (_m *ClientMock) GetVotesByHeight(p *types.BlockHeightParam) ([]byte, error) {
	ret := _m.Called(p)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*types.BlockHeightParam) []byte); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.BlockHeightParam) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Monitor provides a mock function with given fields: ctx, reqUrl, reqPtr, respPtr, cb
func (_m *ClientMock) Monitor(ctx context.Context, reqUrl string, reqPtr interface{}, respPtr interface{}, cb types.WsReadCallback) error {
	ret := _m.Called(ctx, reqUrl, reqPtr, respPtr, cb)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}, types.WsReadCallback) error); ok {
		r0 = rf(ctx, reqUrl, reqPtr, respPtr, cb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorBlock provides a mock function with given fields: ctx, p, cb, scb, errCb
func (_m *ClientMock) MonitorBlock(ctx context.Context, p *types.BlockRequest, cb func(*websocket.Conn, *types.BlockNotification) error, scb func(*websocket.Conn), errCb func(*websocket.Conn, error)) error {
	ret := _m.Called(ctx, p, cb, scb, errCb)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.BlockRequest, func(*websocket.Conn, *types.BlockNotification) error, func(*websocket.Conn), func(*websocket.Conn, error)) error); ok {
		r0 = rf(ctx, p, cb, scb, errCb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorEvent provides a mock function with given fields: ctx, p, cb, errCb
func (_m *ClientMock) MonitorEvent(ctx context.Context, p *types.EventRequest, cb func(*websocket.Conn, *types.EventNotification) error, errCb func(*websocket.Conn, error)) error {
	ret := _m.Called(ctx, p, cb, errCb)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.EventRequest, func(*websocket.Conn, *types.EventNotification) error, func(*websocket.Conn, error)) error); ok {
		r0 = rf(ctx, p, cb, errCb)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewClientMock interface {
	mock.TestingT
	Cleanup(func())
}

// NewClientMock creates a new instance of ClientMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClientMock(t mockConstructorTestingTNewClientMock) *ClientMock {
	mock := &ClientMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
